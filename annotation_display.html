<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COCO Annotation Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .file-input-label {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background-color: #4f46e5;
            color: white;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: 500;
            text-align: center;
        }
        .file-input-label:hover {
            background-color: #4338ca;
        }
        input[type="file"] {
            display: none;
        }
        canvas {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .nav-btn {
            background-color: #4f46e5;
            color: white;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }
        .nav-btn:hover:not(:disabled) {
            background-color: #4338ca;
        }
        .nav-btn:disabled {
            background-color: #a5b4fc;
            cursor: not-allowed;
        }
        .delete-btn {
            background-color: #ef4444;
        }
        .delete-btn:hover {
            background-color: #dc2626;
        }
        .download-btn {
            background-color: #22c55e;
        }
        .download-btn:hover {
            background-color: #16a34a;
        }
        /* Toggle Switch Styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #4f46e5;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        #image-id-input {
            width: 60px;
            text-align: center;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 0.25rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">COCO Annotation Visualizer</h1>
            <p class="mt-2 text-gray-600">Upload a JSON annotation file and a folder of images to begin.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
            <main class="bg-white p-6 rounded-lg shadow-lg lg:col-span-3">
                <!-- Step-by-step instructions and inputs -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-6">
                    <div class="flex flex-col items-center justify-center bg-gray-50 p-6 rounded-lg border-2 border-dashed border-gray-300">
                        <span class="text-lg font-semibold text-gray-700 mb-2">Step 1: Upload JSON</span>
                        <label for="json-file" class="file-input-label">Select COCO JSON File</label>
                        <input type="file" id="json-file" accept=".json">
                        <span id="json-file-name" class="mt-3 text-sm text-gray-500 truncate max-w-full">No file selected</span>
                    </div>
                    <div class="flex flex-col items-center justify-center bg-gray-50 p-6 rounded-lg border-2 border-dashed border-gray-300">
                        <span class="text-lg font-semibold text-gray-700 mb-2">Step 2: Upload Folder</span>
                        <label for="image-folder" class="file-input-label">Select Image Folder</label>
                        <input type="file" id="image-folder" webkitdirectory directory>
                        <span id="image-folder-name" class="mt-3 text-sm text-gray-500 truncate max-w-full">No folder selected</span>
                    </div>
                </div>
                
                <!-- Controls for RLE interpretation -->
                <div class="flex justify-center items-center gap-4 mb-6">
                    <span class="font-medium text-gray-700">Interpret List-of-Lists as RLE:</span>
                    <label class="switch">
                        <input type="checkbox" id="rle-toggle">
                        <span class="slider"></span>
                    </label>
                </div>

                <!-- Status and Warning Message Area -->
                <div id="status-message" class="text-center p-4 mb-6 rounded-md bg-blue-100 text-blue-800 hidden"></div>
                <div id="warning-message" class="text-left p-4 mb-6 rounded-md bg-yellow-100 text-yellow-800 hidden"></div>


                <!-- Canvas for Rendering -->
                <div id="canvas-container" class="w-full flex justify-center">
                    <canvas id="annotation-canvas"></canvas>
                </div>
                
                <!-- Navigation Controls -->
                <div id="navigation-controls" class="mt-4 flex items-center justify-center gap-4 hidden">
                    <button id="prev-btn" class="nav-btn">← Previous</button>
                    <div id="image-counter" class="text-gray-700 font-medium flex items-center gap-2">
                        <span id="image-filename"></span>
                        <span>(ID: <input type="number" id="image-id-input" />)</span>
                        <span id="image-count-total"></span>
                    </div>
                    <button id="next-btn" class="nav-btn">Next →</button>
                    <button id="delete-btn" class="nav-btn delete-btn">Delete (d)</button>
                    <button id="download-btn" class="nav-btn download-btn">Download JSON</button>
                </div>

                <!-- Legend -->
                <div id="legend" class="mt-8">
                    <h3 class="text-xl font-semibold mb-2 text-center">Category Legend</h3>
                    <div id="legend-items" class="flex flex-wrap justify-center gap-4"></div>
                </div>
            </main>

            <aside class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-xl font-semibold mb-4 text-center">Deleted Images</h3>
                <ul id="deleted-images-list" class="list-disc list-inside text-gray-600 space-y-1 mb-4">
                    <!-- Deleted image names will be populated here -->
                </ul>
                <button id="download-deleted-csv-btn" class="nav-btn download-btn w-full">Download CSV</button>
            </aside>
        </div>
    </div>

    <script>
        // --- State Management ---
        let cocoData = null;
        let originalCocoData = null;
        let imageFiles = new Map();
        let renderableImages = [];
        let currentImageIndex = -1;
        let deletedImageIds = new Set();
        let interpretAsRLE = false;

        // --- DOM Elements ---
        const jsonInput = document.getElementById('json-file');
        const imageFolderInput = document.getElementById('image-folder');
        const jsonFileNameSpan = document.getElementById('json-file-name');
        const imageFolderNameSpan = document.getElementById('image-folder-name');
        const canvas = document.getElementById('annotation-canvas');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const warningMessage = document.getElementById('warning-message');
        const legendContainer = document.getElementById('legend-items');
        const navControls = document.getElementById('navigation-controls');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const downloadBtn = document.getElementById('download-btn');
        const imageIdInput = document.getElementById('image-id-input');
        const imageFilenameSpan = document.getElementById('image-filename');
        const imageCountTotalSpan = document.getElementById('image-count-total');
        const deletedImagesList = document.getElementById('deleted-images-list');
        const rleToggle = document.getElementById('rle-toggle');
        const downloadDeletedCsvBtn = document.getElementById('download-deleted-csv-btn');

        // --- Color Palette ---
        const categoryColors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#E7E9ED', '#8A2BE2', '#00CED1', '#FF4500', '#2E8B57', '#DAA520'];
        
        // --- Functions ---
        function getColorForCategory(categoryId) {
            if (categoryId === 1) return '#ef4444';
            return categoryColors[(categoryId - 2 + categoryColors.length) % categoryColors.length];
        }
        
        // --- Event Listeners ---
        jsonInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type === "application/json") {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        originalCocoData = JSON.parse(e.target.result);
                        cocoData = JSON.parse(JSON.stringify(originalCocoData));
                        deletedImageIds.clear();
                        updateDeletedImagesList();
                        jsonFileNameSpan.textContent = file.name;
                        jsonFileNameSpan.classList.add('text-green-600', 'font-medium');
                        prepareAndRenderInitialImage();
                    } catch (error) {
                        statusMessage.textContent = "Error: Invalid JSON file format.";
                        statusMessage.classList.add('bg-red-100', 'text-red-800');
                    }
                };
                reader.readAsText(file);
            }
        });

        imageFolderInput.addEventListener('change', (event) => {
            imageFiles.clear();
            const files = event.target.files;
            for (const file of files) {
                imageFiles.set(file.name, file);
            }
            if (files.length > 0) {
                imageFolderNameSpan.textContent = `${files.length} images selected.`;
                imageFolderNameSpan.classList.add('text-green-600', 'font-medium');
                prepareAndRenderInitialImage();
            }
        });

        rleToggle.addEventListener('change', (event) => {
            interpretAsRLE = event.target.checked;
            if (currentImageIndex !== -1) {
                renderCurrentImage();
            }
        });

        imageIdInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const targetId = parseInt(e.target.value, 10);
                if (!isNaN(targetId)) {
                    const targetIndex = renderableImages.findIndex(img => img.id === targetId);
                    if (targetIndex !== -1) {
                        currentImageIndex = targetIndex;
                        renderCurrentImage();
                    } else {
                        imageIdInput.style.borderColor = 'red';
                        setTimeout(() => { imageIdInput.style.borderColor = '#d1d5db'; }, 1000);
                    }
                }
            }
        });

        prevBtn.addEventListener('click', showPreviousImage);
        nextBtn.addEventListener('click', showNextImage);
        deleteBtn.addEventListener('click', deleteCurrentImageAnnotations);
        downloadBtn.addEventListener('click', downloadEditedJson);
        downloadDeletedCsvBtn.addEventListener('click', downloadDeletedCSV);

        document.addEventListener('keydown', (e) => {
            // Prevent shortcuts when typing in the input field
            if (e.target === imageIdInput) {
                return;
            }

            if (renderableImages.length > 0) {
                if (e.key === 'ArrowLeft') showPreviousImage();
                if (e.key === 'ArrowRight') showNextImage();
                if (e.key === 'd' || e.key === 'D') deleteCurrentImageAnnotations();
            }
        });
        
        function deleteCurrentImageAnnotations() {
            if (currentImageIndex === -1) return;
            const imageIdToDelete = renderableImages[currentImageIndex].id;
            deletedImageIds.add(imageIdToDelete);
            cocoData.annotations = cocoData.annotations.filter(ann => ann.image_id !== imageIdToDelete);
            renderableImages = renderableImages.filter(img => img.id !== imageIdToDelete);
            updateDeletedImagesList();

            if (renderableImages.length === 0) {
                currentImageIndex = -1;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                navControls.classList.add('hidden');
                statusMessage.textContent = 'All available images have been deleted.';
                statusMessage.classList.remove('hidden');
                return;
            }
            if (currentImageIndex >= renderableImages.length) {
                currentImageIndex = renderableImages.length - 1;
            }
            renderCurrentImage();
        }

        function downloadEditedJson() {
            if (!cocoData) return;
            const editedCocoData = {
                ...cocoData,
                images: cocoData.images.filter(img => !deletedImageIds.has(img.id)),
                annotations: cocoData.annotations
            };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(editedCocoData, null, 2));
            const a = document.createElement('a');
            a.href = dataStr;
            a.download = "edited_coco.json";
            a.click();
        }
        
        function downloadDeletedCSV() {
            if (deletedImageIds.size === 0 || !originalCocoData) {
                alert("No images have been deleted.");
                return;
            }

            let csvContent = "Image ID,Image Filename\n";
            deletedImageIds.forEach(id => {
                const imageInfo = originalCocoData.images.find(img => img.id === id);
                if (imageInfo) {
                    csvContent += `${id},${imageInfo.file_name}\n`;
                }
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "deleted_images.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function updateDeletedImagesList() {
            deletedImagesList.innerHTML = '';
            if (!originalCocoData) return;
            deletedImageIds.forEach(id => {
                const info = originalCocoData.images.find(img => img.id === id);
                if (info) {
                    const li = document.createElement('li');
                    li.textContent = info.file_name;
                    deletedImagesList.appendChild(li);
                }
            });
        }

        function prepareAndRenderInitialImage() {
            if (!cocoData || imageFiles.size === 0) return;

            const missingImages = cocoData.images.filter(img => !imageFiles.has(img.file_name));
            if (missingImages.length > 0) {
                let warningHTML = '<strong>Warning:</strong> The following images from the JSON were not found in the selected folder:<ul>';
                missingImages.forEach(img => {
                    warningHTML += `<li class="ml-4 list-disc">ID: ${img.id}, Filename: ${img.file_name}</li>`;
                });
                warningHTML += '</ul>';
                warningMessage.innerHTML = warningHTML;
                warningMessage.classList.remove('hidden');
            } else {
                warningMessage.classList.add('hidden');
            }

            renderableImages = cocoData.images.filter(img => imageFiles.has(img.file_name) && !deletedImageIds.has(img.id));
            if (renderableImages.length === 0) {
                statusMessage.textContent = 'No matching images found.';
                statusMessage.classList.remove('hidden');
                navControls.classList.add('hidden');
                return;
            }
            statusMessage.classList.add('hidden');
            navControls.classList.remove('hidden');
            currentImageIndex = 0;
            renderCurrentImage();
        }

        function showNextImage() {
            if (currentImageIndex < renderableImages.length - 1) {
                currentImageIndex++;
                renderCurrentImage();
            }
        }

        function showPreviousImage() {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                renderCurrentImage();
            }
        }
        
        function renderCurrentImage() {
            if (currentImageIndex < 0) return;
            const imageInfo = renderableImages[currentImageIndex];
            const imageFile = imageFiles.get(imageInfo.file_name);
            const image = new Image();
            image.onload = () => {
                renderAnnotations(image, imageInfo.id);
                updateNavControls();
            };
            image.src = URL.createObjectURL(imageFile);
        }

        function updateNavControls() {
            if (currentImageIndex === -1) {
                imageFilenameSpan.textContent = '';
                imageIdInput.value = '';
                imageCountTotalSpan.textContent = '';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                deleteBtn.disabled = true;
            } else {
                const currentImage = renderableImages[currentImageIndex];
                imageFilenameSpan.textContent = currentImage.file_name;
                imageIdInput.value = currentImage.id;
                imageCountTotalSpan.textContent = `(${currentImageIndex + 1} of ${renderableImages.length})`;
                prevBtn.disabled = currentImageIndex === 0;
                nextBtn.disabled = currentImageIndex === renderableImages.length - 1;
                deleteBtn.disabled = false;
            }
        }

        function rleToImageData(counts, width, height, color) {
            const imageData = new ImageData(width, height);
            const data = imageData.data;
            const [r, g, b] = color.match(/\w\w/g).map(x => parseInt(x, 16));

            let p = 0;
            for (let i = 0; i < counts.length; i++) {
                const value = i % 2;
                const count = counts[i];

                for (let j = 0; j < count; j++) {
                    const col = Math.floor(p / height);
                    const row = p % height;
                    
                    if (value === 1) {
                        const index = (row * width + col) * 4;
                        if (index < data.length) {
                            data[index] = r;
                            data[index + 1] = g;
                            data[index + 2] = b;
                            data[index + 3] = 102;
                        }
                    }
                    p++;
                }
            }
            return imageData;
        }

        function renderAnnotations(image, imageId) {
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, 0, 0);

            const annotationsForImage = cocoData.annotations.filter(ann => ann.image_id === imageId);
            const categoriesUsed = new Set();

            annotationsForImage.forEach(ann => {
                if (ann.iscrowd === 1) return;
                const color = getColorForCategory(ann.category_id);
                categoriesUsed.add(ann.category_id);

                if (ann.bbox) {
                    const [x, y, width, height] = ann.bbox;
                    ctx.save();
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(x, y, width, height);
                    ctx.restore();
                }

                let isPolygonDataAvailable = false;
                if (ann.segmentation) {
                    const isListOfLists = Array.isArray(ann.segmentation) && ann.segmentation.length > 0 && Array.isArray(ann.segmentation[0]);

                    if (isListOfLists && !interpretAsRLE) {
                        isPolygonDataAvailable = true;
                        ann.segmentation.forEach(seg => {
                            ctx.fillStyle = `${color}66`;
                            ctx.beginPath();
                            ctx.moveTo(seg[0], seg[1]);
                            for (let i = 2; i < seg.length; i += 2) ctx.lineTo(seg[i], seg[i + 1]);
                            ctx.closePath();
                            ctx.fill();
                            ctx.fillStyle = color;
                            for (let i = 0; i < seg.length; i += 2) {
                                ctx.beginPath();
                                ctx.arc(seg[i], seg[i + 1], 2.5, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        });
                    } else { // RLE or toggled to RLE
                        const counts = isListOfLists ? ann.segmentation[0] : ann.segmentation;
                        if (Array.isArray(counts)) {
                             const maskImageData = rleToImageData(counts, image.width, image.height, color);
                             const tempCanvas = document.createElement('canvas');
                             tempCanvas.width = maskImageData.width;
                             tempCanvas.height = maskImageData.height;
                             tempCanvas.getContext('2d').putImageData(maskImageData, 0, 0);
                             ctx.drawImage(tempCanvas, 0, 0);
                        }
                    }
                }

                if (ann.keypoints) {
                    let bl_x, bl_y, br_x, br_y;
                    if (ann.keypoints.length === 4) {
                        [bl_x, bl_y, br_x, br_y] = ann.keypoints;
                    } else if (ann.keypoints.length === 2 && isPolygonDataAvailable) {
                        const seg = ann.segmentation[0];
                        const [i_bl, i_br] = ann.keypoints;
                        if (i_bl + 1 < seg.length && i_br + 1 < seg.length) {
                            [bl_x, bl_y, br_x, br_y] = [seg[i_bl], seg[i_bl + 1], seg[i_br], seg[i_br + 1]];
                        }
                    }

                    if (bl_x !== undefined) {
                        ctx.fillStyle = '#ffff00'; // Yellow BL
                        ctx.beginPath();
                        ctx.arc(bl_x, bl_y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = '#00ffff'; // Cyan BR
                        ctx.beginPath();
                        ctx.arc(br_x, br_y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        const angleRad = Math.atan2(br_y - bl_y, br_x - bl_x) + (Math.PI / 2);
                        drawAnnotationArrow(ann, angleRad, isPolygonDataAvailable);
                    }
                }
            });
            updateLegend(categoriesUsed);
        }

        function drawAnnotationArrow(annotation, angleRad, isPolygon) {
            let centerX, centerY;
            if (isPolygon) {
                const points = annotation.segmentation[0];
                centerX = 0;
                centerY = 0;
                for (let i = 0; i < points.length; i += 2) {
                    centerX += points[i];
                    centerY += points[i + 1];
                }
                centerX /= (points.length / 2);
                centerY /= (points.length / 2);
            } else if (annotation.bbox) {
                const [x, y, w, h] = annotation.bbox;
                centerX = x + w / 2;
                centerY = y + h / 2;
            } else return;

            const arrowLength = 50;
            const endX = centerX + arrowLength * Math.cos(angleRad);
            const endY = centerY + arrowLength * Math.sin(angleRad);
            drawArrow(ctx, centerX, centerY, endX, endY, '#22c55e', 3);
        }
        
        function drawArrow(context, fromX, fromY, toX, toY, color, lineWidth) {
            const headlen = 10;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            context.save();
            context.strokeStyle = color;
            context.fillStyle = color;
            context.lineWidth = lineWidth;
            context.beginPath();
            context.moveTo(fromX, fromY);
            context.lineTo(toX, toY);
            context.stroke();
            context.beginPath();
            context.moveTo(toX, toY);
            context.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            context.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            context.closePath();
            context.fill();
            context.restore();
        }
        
        function updateLegend(categoryIds) {
            legendContainer.innerHTML = '';
            if (!cocoData) return;
            categoryIds.forEach(id => {
                const cat = cocoData.categories.find(c => c.id === id);
                if (cat) {
                    const color = getColorForCategory(id);
                    const item = document.createElement('div');
                    item.className = 'flex items-center gap-2';
                    item.innerHTML = `<span class="w-4 h-4 rounded-full" style="background-color: ${color};"></span><span class="text-sm font-medium">${cat.name}</span>`;
                    legendContainer.appendChild(item);
                }
            });
        }
    </script>
</body>
</html>
